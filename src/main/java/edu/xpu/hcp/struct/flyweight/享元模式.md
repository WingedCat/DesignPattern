##享元模式
面向对象的思想很好地解决了抽象性的问题，一般也不会出现性能上的问题。但是在某些情况下，对象的数量可能会太多，从而导致了运行时的代价。那么我们如何去避免大量细粒度的对象，同时又不影响客户程序使用面向对象的方式进行操作？

### 意图
运用共享技术有效地支持大量细粒度的对象


### 适用性
- 系统需要存在大量的对象而共享某些本质的，不变的信息。
- 对象可以同时用于多个环境下。
- 在每个实例下，Flyweight可以作为一个独立的对象。


### 组成
- 抽象享元角色（Flyweight）
    - 声明一个接口，通过它可以接收外来的参数（状态），并对新状态做出处理
- 共享具体享元类（SharedConcreteFlyweight）
    - 实现Flyweight接口，并为内部状态（如果有的话）增加存储空间， SharedConcreteFlyweight对象必须是可共享的，它所存储的状态必须是内部的，即它独立存在于自己的环境中
- 不共享具体享元类（UnsharedConcreteFlyweight）
    - 不能共享的享元类，又叫做复合享元类。一个复合享元对象是由多个单享元对象组成，这些组成的对象是可以共享的，但是复合享元类本身并不能共享
- 轻量级类工厂（FlyweightFactory）
    - 创建并管理Flyweight对象
    - 确保享用Flyweight。当用户请求一个Flyweight时， FlyweightFactory提供一个已创建的实例或创建一个实例（如果不存在）
- 客户端（Client）
    - 维持一个对Flyweight的引用。
    - 计算或存储一个或多个Flyweight的外部状态。

### 处理过程
客户初次从轻量级类工厂取Flyweight时，轻量级类工厂创建一个新的具体Flyweight对象，并保存起来，下次客户取用时，就无需再进行创建了，直接在保存池中返回。客户端负责处理Flyweight的状态


## 总结
我们把享元对象的所有状态分成两类，其实前面的例子中letter和fontsize属性在运行时，就形成了两类不同的状态。 
享元对象的第一类状态称为内蕴状态(Internal State)。它不会随环境改变而改变，存储在享元对象内部，因此内蕴状态是可以共享的，对于任何一个享元对象来讲，它的值是完全相同的。我们例子中Character类的letter属性，它代表的状态就是内蕴状态。
享元对象的第二类状态称为外蕴状态(External State)。它会随环境的改变而改变，因此是不可以共享的状态，对于不同的享元对象来讲，它的值可能是不同的。享元对象的外蕴状态必须由客户端保存，在享元对象被创建之后，需要使用的时候再传入到享元对象内部。我们例子中Character类的fontsize属性，它代表的状态就是外蕴状态。
享元的外蕴状态与内蕴状态是两类相互独立的状态，彼此没有关联。
